/* Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
Additional regression testing code for TS API.  This file is included in test_tsapi2.cc, which is generated
by tsapi2.test.py.
*/

#include <unordered_map>
#include <cstdint>
#include <cstdio>
#include <cstdarg>
#include <string_view>
#include <new>

#include <arpa/inet.h>

#include <ts/ts.h>

namespace Tsapi2Test
{
// Each wave of transactions for this test runs in parallel, so no guaranteed order.  To avoid variations in order
// of log output for different transactions, transactions that are part of the same wave must log to different files.
// In order to be available for gold file comparison, the log files are flushed on the TXN_CLOSE hook.

class Logger
{
public:
  void
  open(std::string const &log_file_path)
  {
    fp = std::fopen(log_file_path.c_str(), "w");
    TSReleaseAssert(fp != nullptr);
  }

  void
  flush()
  {
    std::fflush(fp);
  }

  void
  close()
  {
    std::fclose(fp);
  }

  void
  operator()(char const *fmt, ...)
  {
    std::va_list args;
    va_start(args, fmt);
    std::vfprintf(fp, fmt, args);
    va_end(args);
    fputc('\n', fp);
  }

private:
  FILE *fp{nullptr};
};

// Global hooks will trigger for all tests.  This class returns the TxnID for a session or transaction, so
// a hook continuation function can determine which test transaction triggered it.
//
class GetTxnID
{
public:
  static void
  init()
  {
    // This function is in the .cc file generated by tsapi2.test.py, that includes this file.
    //
    createPortToTxnIDMap(_port_to_test_id_map);
  }

  GetTxnID(TSHttpSsn ssnp) { _set_test_id(ssnp); }

  GetTxnID(TSHttpTxn txn)
  {
    TSHttpSsn ssnp = TSHttpTxnSsnGet(txn);

    TSReleaseAssert(!!ssnp);

    _set_test_id(ssnp);
  }

  operator TxnID() const { return _test_id; }

  TxnID
  test_id() const
  {
    return _test_id;
  }

private:
  TxnID _test_id;

  static inline std::unordered_map<std::uint16_t, TxnID> _port_to_test_id_map;

  void
  _set_test_id(TSHttpSsn ssnp)
  {
    sockaddr const *sock_addr = TSHttpSsnIncomingAddrGet(ssnp);

    TSReleaseAssert(sock_addr != nullptr);

    TSReleaseAssert(AF_INET == sock_addr->sa_family);

    auto sock_addr_in = reinterpret_cast<sockaddr_in const *>(sock_addr);

    auto it = _port_to_test_id_map.find(ntohs(sock_addr_in->sin_port));

    TSReleaseAssert(it != _port_to_test_id_map.end());

    _test_id = it->second;
  }
};

using MsgGetFunc = TSReturnCode (*)(TSHttpTxn, TSMBuffer *, TSMLoc *);

// Returns true if X-Request-ID (for requests) and X-Response-ID (for responses) field in the HTTP message header
// contains test_id as the value.  When the status parameter is not none, this indicates the message is a response,
// and this function also checks that the response status is the status given by the parameter.  If test_id is less
// than 0, no ID field check is done.
//
bool
checkHttpTxnReqOrResp(Logger &log, TSHttpTxn txn, MsgGetFunc func, char const *label, int test_id,
                      TSHttpStatus status = TS_HTTP_STATUS_NONE)
{
  TSMBuffer bufp;
  TSMLoc mloc;

  if (func(txn, &bufp, &mloc) != TS_SUCCESS) {
    log("Unable to get handle to %s", label);
    return false;
  }

  bool is_response = (status != TS_HTTP_STATUS_NONE);

  if (is_response) {
    TSHttpStatus status_in_msg = TSHttpHdrStatusGet(bufp, mloc);
    if (status_in_msg != status) {
      log("Status in message (%d) is not the expected status (%d)", static_cast<int>(status_in_msg), static_cast<int>(status));
      return false;
    }
  }

  if (test_id >= 0) {
    std::string_view checked_fld_name{is_response ? "X-Response-ID" : "X-Request-ID"};

    TSMLoc fld_loc = TSMimeHdrFieldFind(bufp, mloc, checked_fld_name.data(), checked_fld_name.length());
    if (TS_NULL_MLOC == fld_loc) {
      log("Unable to find %s field in %s", checked_fld_name.data(), label);
      return false;
    }

    bool value_is_test_id =
      (TSMimeHdrFieldValuesCount(bufp, mloc, fld_loc) == 1) && (TSMimeHdrFieldValueIntGet(bufp, mloc, fld_loc, 0) == test_id);

    TSReleaseAssert(TSHandleMLocRelease(bufp, mloc, fld_loc) == TS_SUCCESS);

    if (value_is_test_id) {
      log("%s ok", label);
    } else {
      log("value of %s field %s is not %d", label, checked_fld_name.data(), test_id);
      return false;
    }
  }
  return true;
}

} // namespace Tsapi2Test

using namespace Tsapi2Test;

// Individual tests are in separate header files.  They depend on the contents of the anonymous namespace in this
// header file.
//
#include "hooks.h"
#include "cache.h"
#include "ssn.h"
#include "transform.h"
#include "parent_proxy.h"

void
TSPluginInit(int argc, const char *argv[])
{
  char PIName[] = "test_tsapi2";

  TSPluginRegistrationInfo info;

  info.plugin_name   = PIName;
  info.vendor_name   = "Apache Software Foundation";
  info.support_email = "dev@trafficserver.apache.org";

  if (TSPluginRegister(&info) != TS_SUCCESS) {
    TSError("%s: Plugin registration failed", PIName);

    return;
  }

  GetTxnID::init();

  HooksTest::init();
  SsnTest::init();
  CacheTest::init();
  TransformTest::init();
  ParentProxyTest::init();
}

namespace
{
class Cleanup
{
public:
  ~Cleanup()
  {
    HooksTest::cleanup();
    SsnTest::cleanup();
    CacheTest::cleanup();
    TransformTest::cleanup();
    ParentProxyTest::cleanup();
  }
};

// Do any needed cleanup for this source file at program termination time.
//
Cleanup cleanup;

} // end anonymous namespace
